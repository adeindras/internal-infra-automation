// Copyright (c) 2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.
import groovy.json.JsonOutput
import groovy.json.JsonSlurper

def userId
def slackThread
def slackChannel

// Set to 'true' for the main pipeline to enable Slack thread creation.
// Set to 'false' for pre/post-flight pipelines to skip Slack notifications.
def isMainPipeline = true

// Please provide the following details to configure this pipeline 
// appropriately based on the intended deployment or task context.
String taskTitle = "Kubecost Deployment"
String taskDesc = "Kubecost Deployment was optional to be deployed in certain environment that need cost analysis in Kubernetes workload"
String taskImpact = "Impact related to services should be none. Additional Cost for Kubecost workload resources"

// Slack channel ID for sending test notifications.
// Defaults to #my-test-channel.
// Update this value if you'd prefer to use your own testing channel.
String channelForTesting = "C091YBUH465"

// This will sent to #report-infra-changes.
String channelReportInfra = "C017L2M1C3D"

envList = getEnvironmentList()
properties(
  [
    parameters([
      choice(choices: envList, description: "Target environment name", name: "TARGET_ENVIRONMENT_NAME"),
      string(defaultValue: '', name: 'slackThreadUrl', description: 'Send the notification to specific Slack Thread (i.e https://accelbyte.slack.com/archives/C080SRE92NA/p1736426045378049) \nLeave this blank if you want to send new Slack thread notification generated by this pipeline'),
      booleanParam(defaultValue: false, name: 'skipPreCheck', description: 'Tick the checkbox if you want to SKIP Pre-Check Step'),
      booleanParam(defaultValue: false, name: 'enableNetworkCosts', description: 'Tick the checkbox if you want to Enable Network Costs by Enable Network Daemonset'),
      booleanParam(defaultValue: false, name: 'deployInSpotInstance', description: 'Tick the checkbox if you want to Deploy kubecost-cost-analyzer in Spot Instance'),
      booleanParam(defaultValue: false, name: 'skipEnableKubecostIrsa', description: 'Tick the checkbox if you want to SKIP Enable Kubecost EKS IRSA'),
      booleanParam(defaultValue: false, name: 'skipCreatePR', description: 'Tick the checkbox if you want to SKIP Create PR Step'),
      booleanParam(defaultValue: false, name: 'skipReconcile', description: 'Tick the checkbox if you want to SKIP Reconcile Step'),
      booleanParam(defaultValue: false, name: 'skipPostValidation', description: 'Tick the checkbox if you want to SKIP Post Validation Step')
    ])
  ]
)

// This is variable that needed after envlist defined
String BUILD_TRIGGER_BY = currentBuild.getBuildCauses()[0].userName
String BB_PR_URL
String slackThreadUrl = params.slackThreadUrl

pipeline {
  agent {
    kubernetes {
      yaml '''
        apiVersion: v1
        kind: Pod
        metadata:
          namespace: jenkins
          annotations:
            karpenter.sh/do-not-disrupt: "true"
        spec:
          serviceAccountName: jenkinscd-automation-platform
          securityContext:
            runAsUser: 1000
          nodeSelector:
            karpenter.sh/capacity-type: on-demand
          containers:
            - name: jnlp
              image: 268237257165.dkr.ecr.us-west-2.amazonaws.com/rollout-pipeline:1.0.2
              resources:
                requests:
                  memory: 1Gi
                  cpu: 500m
                limits:
                  memory: 1Gi
        '''
    }
  }

  environment {
    AWS_CONFIG_FILE="${WORKSPACE}/aws.config"
  }

  stages {
    stage('Skip stages') {
      when { expression { params.TARGET_ENVIRONMENT_NAME == 'blank'} }
      steps {
        echo "Target environment is blank, skipping the rest of the stages..."
      }
    }

    stage('Read Environment Information') {
      when { expression { params.TARGET_ENVIRONMENT_NAME != 'blank' } }
      steps {
        script {
          env.userId = currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause')[0]['userId']
          currentBuild.displayName = "#${BUILD_NUMBER} - ${TARGET_ENVIRONMENT_NAME}"

          def environmentDetails = getEnvironmentDetails(params.TARGET_ENVIRONMENT_NAME)
          env.TARGET_ENVIRONMENT_NAME = params.TARGET_ENVIRONMENT_NAME

          env.TASK_TITLE = taskTitle
          env.TASK_DESC = taskDesc
          env.TASK_IMPACT = taskImpact
          env.CHANNEL_REPORT_INFRA = channelReportInfra
          env.CHANNEL_FOR_TESTING = channelForTesting

          env.CUSTOMER_NAME = sh (label: 'Set CUSTOMER_NAME', returnStdout: true, script: """#!/bin/bash
          echo '$environmentDetails' | jq -r '.customerName'
          """).trim()

          env.PROJECT = sh (label: 'Set CUSTOMER_NAME', returnStdout: true, script: """#!/bin/bash
          echo '$environmentDetails' | jq -r '.project'
          """).trim()

          if (params.TARGET_ENVIRONMENT_NAME == 'accelbyte-justice-stage') {
            env.ENVIRONMENT = 'stage'
            echo 'stage'
          } else {
            env.ENVIRONMENT = sh (label: 'Set ENVIRONMENT', returnStdout: true, script: """#!/bin/bash
            echo '$environmentDetails' | jq -r '.environment'
            """).trim()
          }

          env.AWS_ACCOUNT = sh (label: 'Set AWS_ACCOUNT', returnStdout: true, script: """#!/bin/bash
          echo '$environmentDetails' | jq -r '.account'
          """).trim()

          env.AWS_REGION = sh (label: 'Set AWS_REGION', returnStdout: true, script: """#!/bin/bash
          echo '$environmentDetails' | jq -r '.region'
          """).trim()

          env.IAC_DIR = "$WORKSPACE/iac"
          env.KUBECOST_MANIFEST_PATH_SOURCE = "$IAC_DIR/manifests/clusters/accelbyte/justice/us-west-2/development/sync/extended"
          env.IAC_MANIFEST_PATH = "$IAC_DIR/manifests/clusters/${CUSTOMER_NAME}/${PROJECT}/${AWS_REGION}/${ENVIRONMENT}"
          env.IAC_MANIFEST_EXTENDED_PATH = "$IAC_MANIFEST_PATH/sync/extended"
          env.IRSA_PATH = "$WORKSPACE/iac/live/$AWS_ACCOUNT/$CUSTOMER_NAME/$PROJECT/$AWS_REGION/$ENVIRONMENT/eks_irsa"

          // Pipelines located in the DEVELOPMENT folder (or any non-standard naming) will send notifications to #my-test-channel.
          // Pipelines under the STABLE folder will default to sending notifications #report-infra-changes.
          if (params.slackThreadUrl?.trim()){
              echo "slack thread url = ${slackThreadUrl}"
              env.slackChannel = slackChannelParser(slackThreadUrl)
              echo "slack channel = ${env.slackChannel}"
              env.slackThread = slackThreadParser(slackThreadUrl)
              echo "slack thread = ${env.slackThread}"
          } else if (WORKSPACE.contains("DEVELOPMENT") && params.slackThreadUrl == '') {
              env.slackChannel = env.CHANNEL_FOR_TESTING
          } else if (WORKSPACE.contains("STABLE") && params.slackThreadUrl == ''){
              env.slackChannel = env.CHANNEL_REPORT_INFRA
          } else {
              env.slackChannel = env.CHANNEL_FOR_TESTING
          }
        }
      }
    }

    stage('Preparation') {
      when { expression { params.TARGET_ENVIRONMENT_NAME != 'blank' } }
      steps {
        dir('iac') {
          checkout (
            changelog: false,
            poll: false,
            scm: scmGit(
              branches: [[name: "master"]],
              browser: bitbucket('https://bitbucket.org/accelbyte/iac'),
              extensions: [cloneOption(noTags: true)],
              userRemoteConfigs: [[credentialsId: 'Bitbucket_Build_EPP', url: 'https://engineering-platform-product@bitbucket.org/accelbyte/iac.git']]
            )
          )
        }

        // Configure Default Role
        sh 'echo "[default]" > aws.config'
        sh 'aws configure set web_identity_token_file $AWS_WEB_IDENTITY_TOKEN_FILE --profile default'
        sh 'aws configure set role_arn $AWS_ROLE_ARN --profile default'

        // Configure Automation Platform Role
        sh "aws configure --profile ${TARGET_ENVIRONMENT_NAME}-automation set role_arn arn:aws:iam::${AWS_ACCOUNT}:role/${TARGET_ENVIRONMENT_NAME}-automation-platform"
        sh "aws configure --profile ${TARGET_ENVIRONMENT_NAME}-automation set source_profile default"

        // Configure Automation Platform Terraform Role
        sh "aws configure --profile ${TARGET_ENVIRONMENT_NAME}-automation-terraform set role_arn arn:aws:iam::${AWS_ACCOUNT}:role/${TARGET_ENVIRONMENT_NAME}-automation-platform-terraform"
        sh "aws configure --profile ${TARGET_ENVIRONMENT_NAME}-automation-terraform set source_profile ${TARGET_ENVIRONMENT_NAME}-automation"

        // Set AWS profile to target environment profile from now on.
        script {
          env.AWS_PROFILE = "${TARGET_ENVIRONMENT_NAME}-automation-terraform"
        }

        // Configure kubeconfig
        sh "aws eks --region ${AWS_REGION} --profile ${TARGET_ENVIRONMENT_NAME}-automation-terraform update-kubeconfig --name ${TARGET_ENVIRONMENT_NAME}"
      }
    }

    stage('Sending Slack Notification') {
      when { expression { return params.TARGET_ENVIRONMENT_NAME != 'blank' && isMainPipeline && !params.slackThreadUrl?.trim()} }
      steps {
        script {
          sendSlackNotification()
        }
      }
    }

    stage('Pre-Check') {
      when { expression { params.TARGET_ENVIRONMENT_NAME != 'blank' && params.skipPreCheck != true} }
      steps {
        dir("$IAC_MANIFEST_EXTENDED_PATH") {
          script{
            // Add your scripts here
            successJobReply (":loading: Pre-checking")
            
            sh "bash $WORKSPACE/hosting/rollout/Q3-2025/kubecost-deployment/check_condition.sh"

            def kubecostDeployed = sh(
              script: "kubectl get deployment kubecost-cost-analyzer -n kubecost > /dev/null 2>&1 && echo 'true' || echo 'false'",
              returnStdout: true
              ).trim()
            
            if (fileExists('kubecost.yaml') && kubecostDeployed == 'true') {
              echo "[INFO] Your kubecost deployment is exists and kubecost.yaml detected in manifests file skipping all stages to Post Validation directly!"
              params.skipEnableKubecostIrsa == true
              params.skipCreatePR == true
              params.skipReconcile == true
              params.skipPostValidation == true
              successJobReply( ":check: Pre-check is done, kubecost deployment is exist. *Skipping all stage to Post Validation directly!*")

            } else if (!fileExists('kubecost.yaml') && kubecostDeployed == 'false') {
              successJobReply( ":check: Pre-check is done, kubecost doesn't exist. *Please confirm to proceed in the pipeline console!* <${env.BUILD_URL}console|*View Jenkins Console Output*>" )
              def continueDeploy = input(
                id: 'continueDeploy', 
                message: 'There is no kubecost detected, please proceed to continue kubecost deployment', 
                parameters: [
                  [$class: 'BooleanParameterDefinition', defaultValue: false, description: '', name: 'Continue Kubecost Deployment?']
                ]
              )
            } else {
              error "[ERROR] ❌ Unknown status"
            }
          }
        }
      }
    }

    stage('Update IAC Manifests') {
      when { expression { params.TARGET_ENVIRONMENT_NAME != 'blank' && params.skipCreatePR != true} }
      steps {
        dir("$IAC_MANIFEST_EXTENDED_PATH") {
          script{
            successJobReply( ":loading: Preparing IAC Manifests" )
            echo "[INFO] Preparing the kubecost manifest"
            
            sh "cp ${KUBECOST_MANIFEST_PATH_SOURCE}/kubecost.yaml ./"
            sh "yq -i '.bases += \"./kubecost.yaml\"' ./kustomization.yaml"
            if (params.enableNetworkCosts){
              sh "yq eval '.spec.postBuild.substitute.KUBECOST_NETWORK_COSTS_ENABLED = \"true\"' -i ./kubecost.yaml"
              echo "[INFO] enableNetworkCosts thicked set KUBECOST_NETWORK_COSTS_ENABLED to true"
            }else{
              sh "yq eval 'del(.spec.postBuild.substitute.KUBECOST_NETWORK_COSTS_ENABLED)' -i ./kubecost.yaml"
            }

            if (params.deployInSpotInstance){
              sh "yq eval '.spec.postBuild.substitute.CAPACITY_TYPE = \"spot\"' -i ./kubecost.yaml"
              echo "[INFO] deployInSpotInstance thicked set CAPACITY_TYPE to spot"
            }else{
              sh "yq eval 'del(.spec.postBuild.substitute.CAPACITY_TYPE)' -i ./kubecost.yaml"
            }

            successJobReply(":check: Update IAC Manifests Completed.")
          }
        }
      }
    }

    stage('Applying Kubecot EKS_IRSA') {
      when { expression { params.TARGET_ENVIRONMENT_NAME != 'blank' && params.skipEnableKubecostIrsa != true} }
      steps {
        dir("$IRSA_PATH") {
          script{
            successJobReply( ":loading: Applying Terragrunt Kubecost EKS_IRSA" )
            echo "[INFO] Applying Terragrunt Kubecost EKS_IRSA"

            sh "sed -i '/^  enable_logging_fluentd/a\\  enable_kubecost_s3_exporter                        = true' ./terragrunt.hcl"
            runTerragrunt('init || true')
            runTerragrunt('plan --target="aws_iam_policy.kubecost_s3_exporter[0]" --target="aws_iam_role.kubecost_s3_exporter[0]" --target="aws_iam_role_policy_attachment.kubecost_s3_exporter_policy_attach[0]" -out="enableKubecostEKSIRSA"')

            echo "[INFO] Terragrunt plan complete"
            successJobReply(":terraform: Terragrunt *plan* complete. *Please review the tg plan here*  <${env.BUILD_URL}|*View Jenkins Console Output*> :warning_q:")

            def userEnableKubecostIRSA = input(
              id: 'userInput', 
              message: 'Please REVIEW the Plan CAREFULLY and ensure this DOES NOT DESTROY anything!', 
              parameters: [
                  [$class: 'BooleanParameterDefinition', defaultValue: false, description: '', name: 'Are you sure to proceed terragrunt apply?']
              ]
            )
            if (!userEnableKubecostIRSA) {
              echo "[ERROR] ❌ Build failed: User did not confirm."
              error "❌ Build failed: User did not confirm."
              failedJobReply()
            }

            runTerragrunt('apply "enableKubecostEKSIRSA"')
            successJobReply( ":check: Kubecost EKS_IRSA has applied" )
          }
        }
      }
    }

    stage('Push & Create PR') {
      when { expression { params.TARGET_ENVIRONMENT_NAME != 'blank' && params.skipCreatePR != true} }
      steps {
        dir("$IAC_DIR") {
          script{
            successJobReply( ":loading: Preparing Pull Request" )
            echo "[INFO] Preparing Pull Request"

            def commitMessage = "feat: Enabling Kubecost service in ${TARGET_ENVIRONMENT_NAME} by ${BUILD_TRIGGER_BY}"
            def branchName = "jenkins/enable-kubecost-${params.TARGET_ENVIRONMENT_NAME}-${env.BUILD_NUMBER}"

            pushChanges(branchName, commitMessage, IAC_DIR)

            def prSummary= "Enable Kubecost in ${TARGET_ENVIRONMENT_NAME}"

            def bitbucketModule = load("$WORKSPACE/hosting/rollout/Q3-2025/kubecost-deployment/bitbucket.groovy")
            def prInfo = bitbucketModule.createPR(branchName, commitMessage, prSummary)

            env.BB_PR_URL = prInfo.url

            successJobReply(":check: Pull Request created. *Please review and merge it!* :bitbucket:<${env.BB_PR_URL}|*PR Link*>" )

            timeout(time: 60, unit: 'MINUTES') {
              input(
                id: 'userInput', 
                message: 'Make sure to merge the PR before proceeding!', 
              )
            }
          }
        }
      }
    }
  
    stage('Reconcile Flux System') {
      when { expression { params.TARGET_ENVIRONMENT_NAME != 'blank' && params.skipReconcile != true} }
      steps {
        dir("$WORKSPACE/hosting/rollout/Q3-2025/kubecost-deployment"){
          script{
            successJobReply( ":loading: Reconciling source iac-repo" )
            reconcileGitrepo("iac-repo")
            reconcileKs("cluster-variables")
            reconcileKs("flux-system")
            sh "bash waiting_kustomization.sh"
            successJobReply( ":check: Kubecost Kustomization and Deployment has been deployed :kubecost:" )
          }
        }
      }
    }

      stage('Post Validation') {
      when { expression { params.TARGET_ENVIRONMENT_NAME != 'blank' && params.skipPostValidation != true} }
      steps {
        dir("$IAC_MANIFEST_EXTENDED_PATH"){
          successJobReply(":loading: Checking Post Validation.")
          sh "bash $WORKSPACE/hosting/rollout/Q3-2025/kubecost-deployment/check_condition.sh"
          successJobReply(":check: Checking Post Validation is done. *Please check the pipeline console to see the result summary* :done-stamp:.")
        }
      }
    }

  }

  post {
    success {
      script {
        if (params.TARGET_ENVIRONMENT_NAME != 'blank') {
          summaryJobReply()
        }
      }
    }
    failure {
      script {
        if (params.TARGET_ENVIRONMENT_NAME != 'blank') {
          failedJobReply()
        }
      }
    }
  }
}

// ────────────────────────────────────────────────
// ───── Helper Functions ─────────────────────────
// ────────────────────────────────────────────────

void runTerragrunt(String command) {
  sh "tfenv install"
  sh "AWS_ROLE_ARN='' AWS_WEB_IDENTITY_TOKEN_FILE='' terragrunt ${command}"
}

def getEnvironmentList() {
  envData = []
  withCredentials([string(credentialsId: "AppScriptEndpointUrl", variable: 'appScriptEndpointUrl')]) {
    def get = new URL(appScriptEndpointUrl + "?q=sharedEnvLists").openConnection();
    def getRC = get.getResponseCode();
    println(getRC);
    if(getRC.equals(200)) {
      def jsonSlurper = new JsonSlurper()
      def reply = get.getInputStream().getText()
      def replyMap = jsonSlurper.parseText(reply)
      envData = replyMap
    }
  }

  if (!envData.find()) {
    envData.push("Error getting environment list data")
  } else {
    return envData
  }
}

def formatDuration(def millis) {
  long ms = (long) millis

  def seconds = (ms.intdiv(1000)) % 60
  def minutes = (ms.intdiv(1000 * 60)) % 60
  def hours = (ms.intdiv(1000 * 60 * 60)) % 24
  def days = ms.intdiv(1000 * 60 * 60 * 24)

  return "${days > 0 ? days + 'd ' : ''}${hours > 0 ? hours + 'h ' : ''}${minutes}m ${seconds}s"
}

def successJobReply(String message) {
  withCredentials([string(credentialsId: "ab-deploy-automation-slackbot-token", variable: 'slackToken')]) {
    def reply = new URL("https://slack.com/api/chat.postMessage").openConnection()
    def replyData = [
      channel  : "${env.slackChannel}",
      text     : ":green-ball: ${message}",
      thread_ts: "${env.slackThread}"
    ]

    def jsonReply = JsonOutput.toJson(replyData)
    reply.setRequestMethod("POST")
    reply.setDoOutput(true)
    reply.setRequestProperty("Content-Type", "application/json")
    reply.setRequestProperty("Authorization", "Bearer ${slackToken}")
    reply.getOutputStream().write(jsonReply.getBytes("UTF-8"))
    echo "Slack thread reply status: ${reply.getResponseCode()}"
  }
}

def failedJobReply() {
  withCredentials([string(credentialsId: "ab-deploy-automation-slackbot-token", variable: 'slackToken')]) {
    def reply = new URL("https://slack.com/api/chat.postMessage").openConnection()
    def replyData = [
      channel  : "${env.slackChannel}",
      thread_ts: "${env.slackThread}",
      blocks   : [
        [
          type: "header",
          text: [ type: "plain_text", text: ":red-ball: Pipeline Failed!" ]
        ],
        [
          type: "section",
          text: [ type: "mrkdwn", text: "Something went wrong during the pipeline execution." ]
        ],
        [
          type: "divider"
        ],
        [
          type: "section",
          fields: [
            [ type: "mrkdwn", text: ":jenkins-cutes: <${env.BUILD_URL}console|*View Jenkins Console Output*>" ],
          ]
        ]
      ]
    ]

    def jsonReply = JsonOutput.toJson(replyData)
    reply.setRequestMethod("POST")
    reply.setDoOutput(true)
    reply.setRequestProperty("Content-Type", "application/json")
    reply.setRequestProperty("Authorization", "Bearer ${slackToken}")
    reply.getOutputStream().write(jsonReply.getBytes("UTF-8"))
    echo "Slack thread reply status: ${reply.getResponseCode()}"
  }
}

def summaryJobReply() {
  withCredentials([string(credentialsId: "ab-deploy-automation-slackbot-token", variable: 'slackToken')]) {
    def trackerSheetUrl = "https://docs.google.com/spreadsheets/d/1G9HC1efLMQJ2Z9SrxNgFMdAgEZLk__JOhY-mp8z9nU8/edit?usp=sharing"
    def buildEndTime = System.currentTimeMillis()
    def buildStartTime = currentBuild.getStartTimeInMillis()
    def buildDuration = buildEndTime - buildStartTime

    // Format timestamps in Asia/Jakarta for display
    def startedAt = new Date(buildStartTime).format("HH:mm:ss", TimeZone.getTimeZone('Asia/Jakarta'))
    def endedAt = new Date(buildEndTime).format("HH:mm:ss", TimeZone.getTimeZone('Asia/Jakarta'))

    // Format timestamps in ISO 8601 UTC for Grafana
    def fromUtc = new Date(buildStartTime).format("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC"))
    def toUtc = new Date(buildEndTime).format("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("UTC"))

    // Compose Grafana URL with dynamic time range
    def athenaDatasourceUid = getAthenaDatasourceUid("${TARGET_ENVIRONMENT_NAME}")
    def grafanaUrl = "https://accelbyte.grafana.net/d/ddocd54os4um8e/service-downtime-metric?" +
        "orgId=1" +
        "&from=${URLEncoder.encode(fromUtc, 'UTF-8')}" +
        "&to=${URLEncoder.encode(toUtc, 'UTF-8')}" +
        "&timezone=browser" +
        "&var-EnvironmentName=${TARGET_ENVIRONMENT_NAME}" +
        "&var-ServiceName=justice-lobby-server" +
        "&var-StatusPageServiceName=Lobby" +
        "&var-athena_datasource=${athenaDatasourceUid}" +
        "&viewPanel=panel-7"

    def reply = new URL("https://slack.com/api/chat.postMessage").openConnection()
    def replyData = [
      channel  : "${env.slackChannel}",
      thread_ts: "${env.slackThread}",
      blocks   : [
        [
          type: "header",
          text: [ type: "plain_text", text: ":coin_spinning: Pipeline Completed Successfully!" ]
        ],
        [
          type: "section",
          text: [ type: "mrkdwn", text: "*Build Summary*\nPlease ensure the tracker is updated accordingly." ]
        ],
        [
          type: "divider"
        ],
        [
          type: "section",
          fields: [
            [ type: "mrkdwn", text: "*:bust_in_silhouette: Triggered by:*\n${env.userId}" ],
            [ type: "mrkdwn", text: "*:clock1: Start time:*\n${startedAt}" ],
            [ type: "mrkdwn", text: "*:clock4: End time:*\n${endedAt}" ],
            [ type: "mrkdwn", text: "*:hourglass_flowing_sand: Duration:*\n${formatDuration(buildDuration)}" ],
          ]
        ],
        [
          type: "divider"
        ],
        [
          type: "section",
          fields: [
            [ type: "mrkdwn", text: ":spreadsheet: <${trackerSheetUrl}|*Update Maintenance Tracker Sheet*>" ],
            [ type: "mrkdwn", text: ":grafana: <${grafanaUrl}|*View Grafana Downtime Panel*>" ],
            [ type: "mrkdwn", text: ":jenkins-cutes: <${env.BUILD_URL}|*View Pipeline Summary*>" ]
          ]
        ]
      ]
    ]

    def jsonReply = JsonOutput.toJson(replyData)
    reply.setRequestMethod("POST")
    reply.setDoOutput(true)
    reply.setRequestProperty("Content-Type", "application/json")
    reply.setRequestProperty("Authorization", "Bearer ${slackToken}")
    reply.getOutputStream().write(jsonReply.getBytes("UTF-8"))
    echo "Slack thread reply status: ${reply.getResponseCode()}"
  }
}

def sendSlackNotification() {
  withCredentials([string(credentialsId: "ab-deploy-automation-slackbot-token", variable: 'slackToken')]) {
    def post = new URL("https://slack.com/api/chat.postMessage").openConnection()
    def postData = [
      channel: "${env.slackChannel}",
      blocks: [
        [
          type: "header",
          text: [ type: "plain_text", text: ":rocket2: ${env.JOB_BASE_NAME}" ]
        ],
        [
          type: "section",
          text: [ type: "mrkdwn", text: "*${env.TASK_TITLE}* \n${env.TASK_DESC}" ]
        ],
        [
          type: "section",
          fields: [
            [ type: "mrkdwn", text: "*Environment:* \n${params.TARGET_ENVIRONMENT_NAME}" ],
            [ type: "mrkdwn", text: "*Triggered by:* \n${env.userId}" ],
            [ type: "mrkdwn", text: "*Impact:* \n${env.TASK_IMPACT}" ],
            [ type: "mrkdwn", text: "*Pipeline URL:* \n<${env.BUILD_URL}|Click here>" ]
          ]
        ],
        [
          type: "context",
          elements: [[ type: "mrkdwn", text: "@hosting-platform-team @liveops-team please be informed about this activity." ]]
        ]
      ]
    ]

    def jsonPayload = groovy.json.JsonOutput.toJson(postData)
    post.setRequestMethod("POST")
    post.setDoOutput(true)
    post.setRequestProperty("Content-Type", "application/json")
    post.setRequestProperty("Authorization", "Bearer ${slackToken}")
    post.getOutputStream().write(jsonPayload.getBytes("UTF-8"))

    def postRC = post.getResponseCode()
    println "Slack response: ${postRC}"

    if (postRC >= 200 && postRC < 300) {
      def response = post.getInputStream().getText()
      def parsed = new groovy.json.JsonSlurper().parseText(response)
      env.slackThread = parsed.ts
      echo "Slack thread_ts: ${env.slackThread}"
    } else {
      error "❌ Failed to send Slack message. Status code: ${postRC}"
    }
  }
}

def getAthenaDatasourceUid(String environmentName) {
  withCredentials([string(credentialsId: "grafana_central_api_token", variable: 'grafanaToken')]) {
    def grafanaHost = 'https://accelbyte.grafana.net'
    def headers = [[name: 'Authorization', value: "Bearer " + grafanaToken]]

    def response = httpRequest(
      url: grafanaHost + "/api/datasources",
      httpMode: 'GET',
      customHeaders: headers,
      validResponseCodes: '200'
    )

    def datasources = new groovy.json.JsonSlurper().parseText(response.content)
    def matched = datasources.find { it.name == environmentName }

    if (!matched) {
      error "❌ Datasource for environment '${environmentName}' not found."
    }

    return matched.uid
  }
}

void getEnvironmentDetails(envName) {
  def eksClusters = ""
  withCredentials([string(credentialsId: "db-inventory-api-key", variable: 'DB_INVENTORY_API_KEY')]) {
    eksClusters = sh (label: 'Download environment data', returnStdout: true, script: '''#!/bin/bash
    curl -s -XGET -H 'accept: application/json' -H "x-api-key: $DB_INVENTORY_API_KEY" 'https://dbinventory-api.dev.hosting.accelbyte.io/listResourcesByType?ResourceType=EKS'
    ''').trim()
  }

  def environmentDetail = sh (label: 'Get environment details', returnStdout: true, script: """#!/bin/bash
  echo '$eksClusters' | jq '.resources[] | select(.name == "$envName") | {name: .name, region: .region, account: .account} + {customerName: .details.Tags[] | select (.Key == "customer_name").Value} + {project: .details.Tags[] | select (.Key == "project").Value} + {environment: .details.Tags[] | select (.Key == "environment").Value}'
  """).trim()

  return environmentDetail
}

void pushChanges(String branchName, String commitMessage, String pathspec){

  sshagent(['bitbucket-repo-read-only']) {

    sh """#!/bin/bash
        set -e
        export GIT_SSH_COMMAND="ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"

        git checkout -b "$branchName"
        git config --global user.email "build@accelbyte.net"
        git config --global user.name "Build AccelByte"
        git status --short
        git add "$pathspec"
        git commit -m "$commitMessage" || true
        git remote set-url origin git@bitbucket.org:accelbyte/iac.git
        echo "git push --set-upstream origin $branchName"
        git push --set-upstream origin "$branchName"
    """
  }
}

def reconcileKs(ksName) {
  def retries = 0
  def reconcileSucceeded = false

  while (retries < 10) {
    echo "Running flux reconcile for ${ksName} (Attempt ${retries + 1})"

    def reconcileOutput = sh(
        script: "flux reconcile ks -n flux-system ${ksName} --with-source 2>&1 || true",
        returnStdout: true
    ).trim()

    echo reconcileOutput

    if (reconcileOutput.contains("Kustomization reconciliation failed")) {
      echo "[ERROR] ❌ Reconciliation failed, retrying in ${env.RETRY_INTERVAL}s..."
      retries++
      sleep time: 10, unit: 'SECONDS'
    } else if (reconcileOutput.contains("resource is suspended")) {
      echo "⏸︎ Kustomization suspended, please Proceed if you want to resume"
      def resumeKs = input(
        id: 'userInput', 
        message: 'Please proceed to resume kustomization, you may double check if the suspended kustomization is intended or nah', 
        parameters: [
          [$class: 'BooleanParameterDefinition', defaultValue: false, description: '', name: 'Are you sure to resume kustomization. Choose No if you want to resume manually?']
        ]
      )
      if (!resumeKs){
        error "[ERROR] ❌ Kustomization suspended, please resume it first"
      } else {
        echo "Resuming suspended kustomization"
        sh "flux resume kustomization -n flux-system ${ksName}"
        retries++
        sleep time: 10, unit: 'SECONDS'
      }
    } else {
      echo "✅ Reconciliation ${ksName} succeeded."
      reconcileSucceeded = true
      break
    }
  }

  if (!reconcileSucceeded) {
      error "[ERROR] ❌ Reconciliation failed after 10 attempts. Failing the build."
  }
}

def reconcileGitrepo(repoName) {
  def retries = 0
  def reconcileSucceeded = false

  while (retries < 10) {
    echo "Running flux reconcile for ${repoName} (Attempt ${retries + 1})"

    def reconcileOutput = sh(
        script: "flux reconcile source git -n flux-system ${repoName} --with-revision 2>&1 || true",
        returnStdout: true
    ).trim()

    echo reconcileOutput

    if (reconcileOutput.contains("GitRepository reconciliation failed")) {
      echo "[ERROR] ❌ Reconciliation failed, retrying in ${env.RETRY_INTERVAL}s..."
      retries++
      sleep time: 10, unit: 'SECONDS'
    } else if (reconcileOutput.contains("resource is suspended")) {
      echo "⏸︎ GitRepository suspended, please Proceed if you want to resume"
      def resumeGitrepo = input(
        id: 'userInput', 
        message: 'Please proceed to resume GitRepository, you may double check if the suspended GitRepository is intended or nah', 
        parameters: [
          [$class: 'BooleanParameterDefinition', defaultValue: false, description: '', name: 'Are you sure to resume GitRepository. Choose No if you want to resume manually?']
        ]
      )
      if (!resumeGitrepo){
        error "[ERROR] ❌ GitRepository suspended, please resume it first"
      } else {
        echo "Resuming suspended GitRepository"
        sh "flux resume source git -n flux-system ${repoName}"
        retries++
        sleep time: 10, unit: 'SECONDS'
      }
    } else {
      echo "✅ Reconciliation ${repoName} succeeded."
      reconcileSucceeded = true
      break
    }
  }

  if (!reconcileSucceeded) {
      error "[ERROR] ❌ Reconciliation failed after 10 attempts. Failing the build."
  }
}

def slackThreadParser(url) {
    def regex = ~/\/archives\/[A-Za-z0-9]+\/p(\d{16})/
    def matcher = (url =~ regex)

    if (matcher) {
        def timestamp = matcher[0][1]
        return timestamp[0..9] + '.' + timestamp[10..-1]
    } else {
        return null
    }
}

def slackChannelParser(url) {
    def regex = ~/\/archives\/([A-Za-z0-9]+)\/p/
    def matcher = (url =~ regex)

    if (matcher) {
        return matcher[0][1]
    } else {
        return null
    }
}